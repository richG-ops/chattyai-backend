"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/api-client.ts":
/*!*******************************!*\
  !*** ./src/lib/api-client.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiClient: function() { return /* binding */ ApiClient; },\n/* harmony export */   CalendarApiClient: function() { return /* binding */ CalendarApiClient; },\n/* harmony export */   ClientApiClient: function() { return /* binding */ ClientApiClient; },\n/* harmony export */   calendarApi: function() { return /* binding */ calendarApi; },\n/* harmony export */   clientApi: function() { return /* binding */ clientApi; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\r\n * Production-ready API client for TheChattyAI\r\n * Implements retry logic, error handling, and authentication\r\n */ class ApiClient {\n    /**\r\n   * Create a unique request ID for tracking and cancellation\r\n   */ createRequestId() {\n        return \"\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    /**\r\n   * Cancel a specific request or all pending requests\r\n   */ cancelRequest(requestId) {\n        if (requestId) {\n            const controller = this.abortControllers.get(requestId);\n            if (controller) {\n                controller.abort();\n                this.abortControllers.delete(requestId);\n            }\n        } else {\n            // Cancel all pending requests\n            this.abortControllers.forEach((controller)=>controller.abort());\n            this.abortControllers.clear();\n        }\n    }\n    /**\r\n   * Make an API request with retry logic and error handling\r\n   */ async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, retries = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.config.retries;\n        const requestId = this.createRequestId();\n        const controller = new AbortController();\n        this.abortControllers.set(requestId, controller);\n        const url = \"\".concat(this.config.baseUrl).concat(endpoint);\n        const timeout = setTimeout(()=>controller.abort(), this.config.timeout);\n        try {\n            const response = await fetch(url, {\n                ...options,\n                signal: controller.signal,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...this.config.jwtToken && {\n                        \"Authorization\": \"Bearer \".concat(this.config.jwtToken)\n                    },\n                    ...options.headers\n                }\n            });\n            clearTimeout(timeout);\n            this.abortControllers.delete(requestId);\n            if (!response.ok) {\n                const error = new Error(\"API Error: \".concat(response.statusText));\n                error.status = response.status;\n                try {\n                    const errorData = await response.json();\n                    error.message = errorData.error || errorData.message || error.message;\n                    error.details = errorData;\n                } catch (e) {\n                // Response wasn't JSON\n                }\n                // Don't retry on client errors (4xx)\n                if (response.status >= 400 && response.status < 500) {\n                    throw error;\n                }\n                // Retry on server errors (5xx) or network issues\n                if (retries > 0) {\n                    await this.delay(1000 * (this.config.retries - retries + 1));\n                    return this.request(endpoint, options, retries - 1);\n                }\n                throw error;\n            }\n            const data = await response.json();\n            return data;\n        } catch (error) {\n            clearTimeout(timeout);\n            this.abortControllers.delete(requestId);\n            if (error.name === \"AbortError\") {\n                const timeoutError = new Error(\"Request timeout\");\n                timeoutError.code = \"TIMEOUT\";\n                throw timeoutError;\n            }\n            // Retry on network errors\n            if (retries > 0 && this.isNetworkError(error)) {\n                await this.delay(1000 * (this.config.retries - retries + 1));\n                return this.request(endpoint, options, retries - 1);\n            }\n            throw error;\n        }\n    }\n    /**\r\n   * Check if error is a network error\r\n   */ isNetworkError(error) {\n        return error.code === \"ECONNREFUSED\" || error.code === \"ENOTFOUND\" || error.code === \"ETIMEDOUT\" || error.message === \"Failed to fetch\" || error.message === \"Network request failed\";\n    }\n    /**\r\n   * Delay helper for retry logic\r\n   */ delay(ms) {\n        return new Promise((resolve)=>setTimeout(resolve, ms));\n    }\n    /**\r\n   * GET request\r\n   */ async get(endpoint, options) {\n        return this.request(endpoint, {\n            ...options,\n            method: \"GET\"\n        });\n    }\n    /**\r\n   * POST request\r\n   */ async post(endpoint, data, options) {\n        return this.request(endpoint, {\n            ...options,\n            method: \"POST\",\n            body: data ? JSON.stringify(data) : undefined\n        });\n    }\n    /**\r\n   * PUT request\r\n   */ async put(endpoint, data, options) {\n        return this.request(endpoint, {\n            ...options,\n            method: \"PUT\",\n            body: data ? JSON.stringify(data) : undefined\n        });\n    }\n    /**\r\n   * DELETE request\r\n   */ async delete(endpoint, options) {\n        return this.request(endpoint, {\n            ...options,\n            method: \"DELETE\"\n        });\n    }\n    /**\r\n   * Update JWT token\r\n   */ setToken(token) {\n        this.config.jwtToken = token;\n    }\n    constructor(config){\n        this.abortControllers = new Map();\n        this.config = {\n            baseUrl: config.baseUrl,\n            jwtToken: config.jwtToken || \"\",\n            timeout: config.timeout || 30000,\n            retries: config.retries || 3\n        };\n    }\n}\n// Calendar API specific methods\nclass CalendarApiClient extends ApiClient {\n    /**\r\n   * Get available appointment slots\r\n   */ async getAvailability(options) {\n        const params = new URLSearchParams();\n        if (options === null || options === void 0 ? void 0 : options.date) params.append(\"date\", options.date);\n        if (options === null || options === void 0 ? void 0 : options.duration) params.append(\"duration\", options.duration.toString());\n        if (options === null || options === void 0 ? void 0 : options.count) params.append(\"count\", options.count.toString());\n        const endpoint = \"/get-availability\".concat(params.toString() ? \"?\".concat(params) : \"\");\n        console.log(\"\\uD83D\\uDCC5 Fetching availability from:\", endpoint);\n        return this.get(endpoint);\n    }\n    /**\r\n   * Book an appointment\r\n   */ async bookAppointment(data) {\n        console.log(\"\\uD83D\\uDCDD Booking appointment:\", data);\n        return this.post(\"/book-appointment\", data);\n    }\n    /**\r\n   * Check health status\r\n   */ async checkHealth() {\n        console.log(\"\\uD83D\\uDD0D Checking API health\");\n        return this.get(\"/health\");\n    }\n    /**\r\n   * Get client metrics\r\n   */ async getClientMetrics(clientId) {\n        let period = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"today\";\n        console.log(\"\\uD83D\\uDCCA Fetching metrics for client \".concat(clientId, \", period: \").concat(period));\n        return this.get(\"/api/clients/\".concat(clientId, \"/metrics?period=\").concat(period));\n    }\n    /**\r\n   * Get client bookings\r\n   */ async getClientBookings(clientId) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n        console.log(\"\\uD83D\\uDCC5 Fetching bookings for client \".concat(clientId, \", limit: \").concat(limit));\n        return this.get(\"/api/clients/\".concat(clientId, \"/bookings?limit=\").concat(limit));\n    }\n    /**\r\n   * Test connection to backend\r\n   */ async testConnection() {\n        console.log(\"\\uD83D\\uDD17 Testing backend connection\");\n        return this.get(\"/api/test/connection\");\n    }\n    constructor(jwtToken){\n        // Use production backend URL for production, localhost for development\n        const baseUrl = \"http://localhost:4000\" || (0);\n        const token = jwtToken || process.env.NEXT_PUBLIC_JWT_TOKEN || process.env.CALENDAR_API_JWT_TOKEN || \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhcGlfa2V5IjoiMDFiYTE2OGRkMzBjMDM3N2MxZjBjNzRiOTM2ZjQyNzQiLCJjbGllbnRfaWQiOiJkZW1vLWNsaWVudCIsImJ1c2luZXNzX25hbWUiOiJEZW1vIEJ1c2luZXNzIiwiZW1haWwiOiJkZW1vQGJ1c2luZXNzLmNvbSIsImlhdCI6MTc1MjA4NzcwNCwiZXhwIjoxNzgzNjQ1MzA0fQ.xYj4zB62N0vuKwyv_nfdMsewPTR3OFXKke2kcmOxywI\";\n        super({\n            baseUrl,\n            jwtToken: token\n        });\n        console.log(\"\\uD83D\\uDCE1 CalendarApiClient initialized:\", {\n            baseUrl,\n            environment: \"development\",\n            hasToken: !!token,\n            tokenPreview: token ? token.substring(0, 20) + \"...\" : \"none\"\n        });\n    }\n}\n// Client management API\nclass ClientApiClient extends ApiClient {\n    /**\r\n   * Create a new client\r\n   */ async createClient(clientData) {\n        console.log(\"\\uD83C\\uDFE2 Creating new client:\", clientData);\n        return this.post(\"/api/clients\", clientData);\n    }\n    /**\r\n   * Get client profile\r\n   */ async getClientProfile(clientId) {\n        console.log(\"\\uD83D\\uDC64 Fetching client profile for \".concat(clientId));\n        return this.get(\"/api/clients/\".concat(clientId));\n    }\n    constructor(){\n        super({\n            baseUrl: \"http://localhost:4000\" || 0,\n            jwtToken:  true ? localStorage.getItem(\"auth_token\") || \"\" : 0\n        });\n    }\n}\n// Export singleton instances\nconst calendarApi = new CalendarApiClient();\nconst clientApi = new ClientApiClient();\n// Export classes for custom instances\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpLWNsaWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FlRCxNQUFNQTtJQWFKOztHQUVDLEdBQ0Qsa0JBQWtDO1FBQ2hDLE9BQU8sR0FBaUJFLE9BQWRDLEtBQUtDLEdBQUcsSUFBRyxLQUEyQyxPQUF4Q0YsS0FBS0csTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsTUFBTSxDQUFDLEdBQUc7SUFDL0Q7SUFFQTs7R0FFQyxHQUNEQyxjQUFjQyxTQUFrQixFQUFRO1FBQ3RDLElBQUlBLFdBQVc7WUFDYixNQUFNQyxhQUFhLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNDLEdBQUcsQ0FBQ0g7WUFDN0MsSUFBSUMsWUFBWTtnQkFDZEEsV0FBV0csS0FBSztnQkFDaEIsSUFBSSxDQUFDRixnQkFBZ0IsQ0FBQ0csTUFBTSxDQUFDTDtZQUMvQjtRQUNGLE9BQU87WUFDTCw4QkFBOEI7WUFDOUIsSUFBSSxDQUFDRSxnQkFBZ0IsQ0FBQ0ksT0FBTyxDQUFDTCxDQUFBQSxhQUFjQSxXQUFXRyxLQUFLO1lBQzVELElBQUksQ0FBQ0YsZ0JBQWdCLENBQUNLLEtBQUs7UUFDN0I7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBY0MsUUFDWkMsUUFBZ0IsRUFHSjtZQUZaQyxVQUFBQSxpRUFBdUIsQ0FBQyxHQUN4QkMsVUFBQUEsaUVBQVUsSUFBSSxDQUFDQyxNQUFNLENBQUNELE9BQU87UUFFN0IsTUFBTVgsWUFBWSxJQUFJLENBQUNSLGVBQWU7UUFDdEMsTUFBTVMsYUFBYSxJQUFJWTtRQUN2QixJQUFJLENBQUNYLGdCQUFnQixDQUFDWSxHQUFHLENBQUNkLFdBQVdDO1FBRXJDLE1BQU1jLE1BQU0sR0FBeUJOLE9BQXRCLElBQUksQ0FBQ0csTUFBTSxDQUFDSSxPQUFPLEVBQVksT0FBVFA7UUFDckMsTUFBTVEsVUFBVUMsV0FBVyxJQUFNakIsV0FBV0csS0FBSyxJQUFJLElBQUksQ0FBQ1EsTUFBTSxD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LE1BQU1rQyxZQUFZLElBQUlQLGtCQUFpQjtBQUU5QyxzQ0FBc0M7QUFDUiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2FwaS1jbGllbnQudHM/YWMxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogUHJvZHVjdGlvbi1yZWFkeSBBUEkgY2xpZW50IGZvciBUaGVDaGF0dHlBSVxyXG4gKiBJbXBsZW1lbnRzIHJldHJ5IGxvZ2ljLCBlcnJvciBoYW5kbGluZywgYW5kIGF1dGhlbnRpY2F0aW9uXHJcbiAqL1xyXG5cclxuaW50ZXJmYWNlIEFwaUNvbmZpZyB7XHJcbiAgYmFzZVVybDogc3RyaW5nXHJcbiAgand0VG9rZW4/OiBzdHJpbmdcclxuICB0aW1lb3V0PzogbnVtYmVyXHJcbiAgcmV0cmllcz86IG51bWJlclxyXG59XHJcblxyXG5pbnRlcmZhY2UgQXBpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgc3RhdHVzPzogbnVtYmVyXHJcbiAgY29kZT86IHN0cmluZ1xyXG4gIGRldGFpbHM/OiBhbnlcclxufVxyXG5cclxuY2xhc3MgQXBpQ2xpZW50IHtcclxuICBwcml2YXRlIGNvbmZpZzogUmVxdWlyZWQ8QXBpQ29uZmlnPlxyXG4gIHByaXZhdGUgYWJvcnRDb250cm9sbGVyczogTWFwPHN0cmluZywgQWJvcnRDb250cm9sbGVyPiA9IG5ldyBNYXAoKVxyXG5cclxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEFwaUNvbmZpZykge1xyXG4gICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgIGJhc2VVcmw6IGNvbmZpZy5iYXNlVXJsLFxyXG4gICAgICBqd3RUb2tlbjogY29uZmlnLmp3dFRva2VuIHx8ICcnLFxyXG4gICAgICB0aW1lb3V0OiBjb25maWcudGltZW91dCB8fCAzMDAwMCxcclxuICAgICAgcmV0cmllczogY29uZmlnLnJldHJpZXMgfHwgM1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgdW5pcXVlIHJlcXVlc3QgSUQgZm9yIHRyYWNraW5nIGFuZCBjYW5jZWxsYXRpb25cclxuICAgKi9cclxuICBwcml2YXRlIGNyZWF0ZVJlcXVlc3RJZCgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGAke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbmNlbCBhIHNwZWNpZmljIHJlcXVlc3Qgb3IgYWxsIHBlbmRpbmcgcmVxdWVzdHNcclxuICAgKi9cclxuICBjYW5jZWxSZXF1ZXN0KHJlcXVlc3RJZD86IHN0cmluZyk6IHZvaWQge1xyXG4gICAgaWYgKHJlcXVlc3RJZCkge1xyXG4gICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5hYm9ydENvbnRyb2xsZXJzLmdldChyZXF1ZXN0SWQpXHJcbiAgICAgIGlmIChjb250cm9sbGVyKSB7XHJcbiAgICAgICAgY29udHJvbGxlci5hYm9ydCgpXHJcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXJzLmRlbGV0ZShyZXF1ZXN0SWQpXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIENhbmNlbCBhbGwgcGVuZGluZyByZXF1ZXN0c1xyXG4gICAgICB0aGlzLmFib3J0Q29udHJvbGxlcnMuZm9yRWFjaChjb250cm9sbGVyID0+IGNvbnRyb2xsZXIuYWJvcnQoKSlcclxuICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXJzLmNsZWFyKClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1ha2UgYW4gQVBJIHJlcXVlc3Qgd2l0aCByZXRyeSBsb2dpYyBhbmQgZXJyb3IgaGFuZGxpbmdcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIHJlcXVlc3Q8VD4oXHJcbiAgICBlbmRwb2ludDogc3RyaW5nLFxyXG4gICAgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fSxcclxuICAgIHJldHJpZXMgPSB0aGlzLmNvbmZpZy5yZXRyaWVzXHJcbiAgKTogUHJvbWlzZTxUPiB7XHJcbiAgICBjb25zdCByZXF1ZXN0SWQgPSB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpXHJcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXHJcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlcnMuc2V0KHJlcXVlc3RJZCwgY29udHJvbGxlcilcclxuXHJcbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmNvbmZpZy5iYXNlVXJsfSR7ZW5kcG9pbnR9YFxyXG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aGlzLmNvbmZpZy50aW1lb3V0KVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XHJcbiAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAuLi4odGhpcy5jb25maWcuand0VG9rZW4gJiYge1xyXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5qd3RUb2tlbn1gXHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuXHJcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxyXG4gICAgICB0aGlzLmFib3J0Q29udHJvbGxlcnMuZGVsZXRlKHJlcXVlc3RJZClcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvcjogQXBpRXJyb3IgPSBuZXcgRXJyb3IoYEFQSSBFcnJvcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXHJcbiAgICAgICAgZXJyb3Iuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzXHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBlcnJvckRhdGEuZXJyb3IgfHwgZXJyb3JEYXRhLm1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZVxyXG4gICAgICAgICAgZXJyb3IuZGV0YWlscyA9IGVycm9yRGF0YVxyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgLy8gUmVzcG9uc2Ugd2Fzbid0IEpTT05cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvbid0IHJldHJ5IG9uIGNsaWVudCBlcnJvcnMgKDR4eClcclxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA1MDApIHtcclxuICAgICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXRyeSBvbiBzZXJ2ZXIgZXJyb3JzICg1eHgpIG9yIG5ldHdvcmsgaXNzdWVzXHJcbiAgICAgICAgaWYgKHJldHJpZXMgPiAwKSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLmRlbGF5KDEwMDAgKiAodGhpcy5jb25maWcucmV0cmllcyAtIHJldHJpZXMgKyAxKSlcclxuICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8VD4oZW5kcG9pbnQsIG9wdGlvbnMsIHJldHJpZXMgLSAxKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICByZXR1cm4gZGF0YSBhcyBUXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxyXG4gICAgICB0aGlzLmFib3J0Q29udHJvbGxlcnMuZGVsZXRlKHJlcXVlc3RJZClcclxuXHJcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcclxuICAgICAgICBjb25zdCB0aW1lb3V0RXJyb3I6IEFwaUVycm9yID0gbmV3IEVycm9yKCdSZXF1ZXN0IHRpbWVvdXQnKVxyXG4gICAgICAgIHRpbWVvdXRFcnJvci5jb2RlID0gJ1RJTUVPVVQnXHJcbiAgICAgICAgdGhyb3cgdGltZW91dEVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJldHJ5IG9uIG5ldHdvcmsgZXJyb3JzXHJcbiAgICAgIGlmIChyZXRyaWVzID4gMCAmJiB0aGlzLmlzTmV0d29ya0Vycm9yKGVycm9yKSkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZGVsYXkoMTAwMCAqICh0aGlzLmNvbmZpZy5yZXRyaWVzIC0gcmV0cmllcyArIDEpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Q8VD4oZW5kcG9pbnQsIG9wdGlvbnMsIHJldHJpZXMgLSAxKVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgZXJyb3IgaXMgYSBuZXR3b3JrIGVycm9yXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBpc05ldHdvcmtFcnJvcihlcnJvcjogYW55KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gZXJyb3IuY29kZSA9PT0gJ0VDT05OUkVGVVNFRCcgfHxcclxuICAgICAgICAgICBlcnJvci5jb2RlID09PSAnRU5PVEZPVU5EJyB8fFxyXG4gICAgICAgICAgIGVycm9yLmNvZGUgPT09ICdFVElNRURPVVQnIHx8XHJcbiAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9PT0gJ0ZhaWxlZCB0byBmZXRjaCcgfHxcclxuICAgICAgICAgICBlcnJvci5tZXNzYWdlID09PSAnTmV0d29yayByZXF1ZXN0IGZhaWxlZCdcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGF5IGhlbHBlciBmb3IgcmV0cnkgbG9naWNcclxuICAgKi9cclxuICBwcml2YXRlIGRlbGF5KG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR0VUIHJlcXVlc3RcclxuICAgKi9cclxuICBhc3luYyBnZXQ8VD4oZW5kcG9pbnQ6IHN0cmluZywgb3B0aW9ucz86IFJlcXVlc3RJbml0KTogUHJvbWlzZTxUPiB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PFQ+KGVuZHBvaW50LCB7XHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgIG1ldGhvZDogJ0dFVCdcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQT1NUIHJlcXVlc3RcclxuICAgKi9cclxuICBhc3luYyBwb3N0PFQ+KGVuZHBvaW50OiBzdHJpbmcsIGRhdGE/OiBhbnksIG9wdGlvbnM/OiBSZXF1ZXN0SW5pdCk6IFByb21pc2U8VD4ge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxUPihlbmRwb2ludCwge1xyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgYm9keTogZGF0YSA/IEpTT04uc3RyaW5naWZ5KGRhdGEpIDogdW5kZWZpbmVkXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUFVUIHJlcXVlc3RcclxuICAgKi9cclxuICBhc3luYyBwdXQ8VD4oZW5kcG9pbnQ6IHN0cmluZywgZGF0YT86IGFueSwgb3B0aW9ucz86IFJlcXVlc3RJbml0KTogUHJvbWlzZTxUPiB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0PFQ+KGVuZHBvaW50LCB7XHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgIGJvZHk6IGRhdGEgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IHVuZGVmaW5lZFxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERFTEVURSByZXF1ZXN0XHJcbiAgICovXHJcbiAgYXN5bmMgZGVsZXRlPFQ+KGVuZHBvaW50OiBzdHJpbmcsIG9wdGlvbnM/OiBSZXF1ZXN0SW5pdCk6IFByb21pc2U8VD4ge1xyXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdDxUPihlbmRwb2ludCwge1xyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgICBtZXRob2Q6ICdERUxFVEUnXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIEpXVCB0b2tlblxyXG4gICAqL1xyXG4gIHNldFRva2VuKHRva2VuOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIHRoaXMuY29uZmlnLmp3dFRva2VuID0gdG9rZW5cclxuICB9XHJcbn1cclxuXHJcbi8vIENhbGVuZGFyIEFQSSBzcGVjaWZpYyBtZXRob2RzXHJcbmV4cG9ydCBjbGFzcyBDYWxlbmRhckFwaUNsaWVudCBleHRlbmRzIEFwaUNsaWVudCB7XHJcbiAgY29uc3RydWN0b3Ioand0VG9rZW4/OiBzdHJpbmcpIHtcclxuICAgIC8vIFVzZSBwcm9kdWN0aW9uIGJhY2tlbmQgVVJMIGZvciBwcm9kdWN0aW9uLCBsb2NhbGhvc3QgZm9yIGRldmVsb3BtZW50XHJcbiAgICBjb25zdCBiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCBcclxuICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nIFxyXG4gICAgICAgICAgICAgICAgICAgICA/ICdodHRwczovL2NoYXR0eWFpLWNhbGVuZGFyLWJvdC0xLm9ucmVuZGVyLmNvbScgXHJcbiAgICAgICAgICAgICAgICAgICAgIDogJ2h0dHA6Ly9sb2NhbGhvc3Q6NDAwMCcpXHJcbiAgICBcclxuICAgIGNvbnN0IHRva2VuID0gand0VG9rZW4gfHwgXHJcbiAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfSldUX1RPS0VOIHx8IFxyXG4gICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52LkNBTEVOREFSX0FQSV9KV1RfVE9LRU4gfHxcclxuICAgICAgICAgICAgICAgICAnZXlKaGJHY2lPaUpJVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SmhjR2xmYTJWNUlqb2lNREZpWVRFMk9HUmtNekJqTURNM04yTXhaakJqTnpSaU9UTTJaalF5TnpRaUxDSmpiR2xsYm5SZmFXUWlPaUprWlcxdkxXTnNhV1Z1ZENJc0ltSjFjMmx1WlhOelgyNWhiV1VpT2lKRVpXMXZJRUoxYzJsdVpYTnpJaXdpWlcxaGFXd2lPaUprWlcxdlFHSjFjMmx1WlhOekxtTnZiU0lzSW1saGRDSTZNVGMxTWpBNE56Y3dOQ3dpWlhod0lqb3hOemd6TmpRMU16QTBmUS54WWo0ekI2Mk4wdnVLd3l2X25mZE1zZXdQVFIzT0ZYS2tlMmtjbU94eXdJJ1xyXG4gICAgXHJcbiAgICBzdXBlcih7XHJcbiAgICAgIGJhc2VVcmwsXHJcbiAgICAgIGp3dFRva2VuOiB0b2tlblxyXG4gICAgfSlcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ/Cfk6EgQ2FsZW5kYXJBcGlDbGllbnQgaW5pdGlhbGl6ZWQ6Jywge1xyXG4gICAgICBiYXNlVXJsLFxyXG4gICAgICBlbnZpcm9ubWVudDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYsXHJcbiAgICAgIGhhc1Rva2VuOiAhIXRva2VuLFxyXG4gICAgICB0b2tlblByZXZpZXc6IHRva2VuID8gdG9rZW4uc3Vic3RyaW5nKDAsIDIwKSArICcuLi4nIDogJ25vbmUnXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGF2YWlsYWJsZSBhcHBvaW50bWVudCBzbG90c1xyXG4gICAqL1xyXG4gIGFzeW5jIGdldEF2YWlsYWJpbGl0eShvcHRpb25zPzoge1xyXG4gICAgZGF0ZT86IHN0cmluZ1xyXG4gICAgZHVyYXRpb24/OiBudW1iZXJcclxuICAgIGNvdW50PzogbnVtYmVyXHJcbiAgfSkge1xyXG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXHJcbiAgICBpZiAob3B0aW9ucz8uZGF0ZSkgcGFyYW1zLmFwcGVuZCgnZGF0ZScsIG9wdGlvbnMuZGF0ZSlcclxuICAgIGlmIChvcHRpb25zPy5kdXJhdGlvbikgcGFyYW1zLmFwcGVuZCgnZHVyYXRpb24nLCBvcHRpb25zLmR1cmF0aW9uLnRvU3RyaW5nKCkpXHJcbiAgICBpZiAob3B0aW9ucz8uY291bnQpIHBhcmFtcy5hcHBlbmQoJ2NvdW50Jywgb3B0aW9ucy5jb3VudC50b1N0cmluZygpKVxyXG5cclxuICAgIGNvbnN0IGVuZHBvaW50ID0gYC9nZXQtYXZhaWxhYmlsaXR5JHtwYXJhbXMudG9TdHJpbmcoKSA/IGA/JHtwYXJhbXN9YCA6ICcnfWBcclxuICAgIGNvbnNvbGUubG9nKCfwn5OFIEZldGNoaW5nIGF2YWlsYWJpbGl0eSBmcm9tOicsIGVuZHBvaW50KVxyXG4gICAgXHJcbiAgICByZXR1cm4gdGhpcy5nZXQ8e1xyXG4gICAgICBzbG90czogQXJyYXk8e1xyXG4gICAgICAgIHN0YXJ0OiBzdHJpbmdcclxuICAgICAgICBlbmQ6IHN0cmluZ1xyXG4gICAgICB9PlxyXG4gICAgfT4oZW5kcG9pbnQpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCb29rIGFuIGFwcG9pbnRtZW50XHJcbiAgICovXHJcbiAgYXN5bmMgYm9va0FwcG9pbnRtZW50KGRhdGE6IHtcclxuICAgIHN0YXJ0OiBzdHJpbmdcclxuICAgIGVuZDogc3RyaW5nXHJcbiAgICBzdW1tYXJ5OiBzdHJpbmdcclxuICAgIGN1c3RvbWVyTmFtZT86IHN0cmluZ1xyXG4gICAgY3VzdG9tZXJQaG9uZT86IHN0cmluZ1xyXG4gICAgbm90ZXM/OiBzdHJpbmdcclxuICB9KSB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+TnSBCb29raW5nIGFwcG9pbnRtZW50OicsIGRhdGEpXHJcbiAgICByZXR1cm4gdGhpcy5wb3N0PHsgc3VjY2VzczogYm9vbGVhbiB9PignL2Jvb2stYXBwb2ludG1lbnQnLCBkYXRhKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaGVhbHRoIHN0YXR1c1xyXG4gICAqL1xyXG4gIGFzeW5jIGNoZWNrSGVhbHRoKCkge1xyXG4gICAgY29uc29sZS5sb2coJ/CflI0gQ2hlY2tpbmcgQVBJIGhlYWx0aCcpXHJcbiAgICByZXR1cm4gdGhpcy5nZXQ8e1xyXG4gICAgICBzdGF0dXM6IHN0cmluZ1xyXG4gICAgICB0aW1lc3RhbXA6IHN0cmluZ1xyXG4gICAgfT4oJy9oZWFsdGgnKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGNsaWVudCBtZXRyaWNzXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0Q2xpZW50TWV0cmljcyhjbGllbnRJZDogc3RyaW5nLCBwZXJpb2Q6ICd0b2RheScgfCAnd2VlaycgfCAnbW9udGgnID0gJ3RvZGF5Jykge1xyXG4gICAgY29uc29sZS5sb2coYPCfk4ogRmV0Y2hpbmcgbWV0cmljcyBmb3IgY2xpZW50ICR7Y2xpZW50SWR9LCBwZXJpb2Q6ICR7cGVyaW9kfWApXHJcbiAgICByZXR1cm4gdGhpcy5nZXQ8e1xyXG4gICAgICBzdWNjZXNzOiBib29sZWFuXHJcbiAgICAgIG1ldHJpY3M6IGFueVxyXG4gICAgICB0aW1lc3RhbXA6IHN0cmluZ1xyXG4gICAgfT4oYC9hcGkvY2xpZW50cy8ke2NsaWVudElkfS9tZXRyaWNzP3BlcmlvZD0ke3BlcmlvZH1gKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGNsaWVudCBib29raW5nc1xyXG4gICAqL1xyXG4gIGFzeW5jIGdldENsaWVudEJvb2tpbmdzKGNsaWVudElkOiBzdHJpbmcsIGxpbWl0OiBudW1iZXIgPSAxMCkge1xyXG4gICAgY29uc29sZS5sb2coYPCfk4UgRmV0Y2hpbmcgYm9va2luZ3MgZm9yIGNsaWVudCAke2NsaWVudElkfSwgbGltaXQ6ICR7bGltaXR9YClcclxuICAgIHJldHVybiB0aGlzLmdldDx7XHJcbiAgICAgIHN1Y2Nlc3M6IGJvb2xlYW5cclxuICAgICAgYm9va2luZ3M6IGFueVtdXHJcbiAgICAgIHRvdGFsOiBudW1iZXJcclxuICAgIH0+KGAvYXBpL2NsaWVudHMvJHtjbGllbnRJZH0vYm9va2luZ3M/bGltaXQ9JHtsaW1pdH1gKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGVzdCBjb25uZWN0aW9uIHRvIGJhY2tlbmRcclxuICAgKi9cclxuICBhc3luYyB0ZXN0Q29ubmVjdGlvbigpIHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5SXIFRlc3RpbmcgYmFja2VuZCBjb25uZWN0aW9uJylcclxuICAgIHJldHVybiB0aGlzLmdldDx7XHJcbiAgICAgIHN0YXR1czogc3RyaW5nXHJcbiAgICAgIHRpbWVzdGFtcDogc3RyaW5nXHJcbiAgICAgIHNlcnZlcjogc3RyaW5nXHJcbiAgICAgIHZlcnNpb246IHN0cmluZ1xyXG4gICAgfT4oJy9hcGkvdGVzdC9jb25uZWN0aW9uJylcclxuICB9XHJcbn1cclxuXHJcbi8vIENsaWVudCBtYW5hZ2VtZW50IEFQSVxyXG5leHBvcnQgY2xhc3MgQ2xpZW50QXBpQ2xpZW50IGV4dGVuZHMgQXBpQ2xpZW50IHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKHtcclxuICAgICAgYmFzZVVybDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo0MDAwJyxcclxuICAgICAgand0VG9rZW46IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhfdG9rZW4nKSB8fCAnJyA6ICcnXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGNsaWVudFxyXG4gICAqL1xyXG4gIGFzeW5jIGNyZWF0ZUNsaWVudChjbGllbnREYXRhOiB7XHJcbiAgICBidXNpbmVzc05hbWU6IHN0cmluZ1xyXG4gICAgYnVzaW5lc3NUeXBlOiBzdHJpbmdcclxuICAgIG93bmVyTmFtZTogc3RyaW5nXHJcbiAgICBlbWFpbDogc3RyaW5nXHJcbiAgICBwaG9uZTogc3RyaW5nXHJcbiAgICBhZGRyZXNzPzogc3RyaW5nXHJcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZ1xyXG4gICAgc2VydmljZXM/OiBzdHJpbmdbXVxyXG4gICAgd29ya2luZ0hvdXJzPzoge1xyXG4gICAgICBzdGFydDogc3RyaW5nXHJcbiAgICAgIGVuZDogc3RyaW5nXHJcbiAgICB9XHJcbiAgICB0aW1lWm9uZT86IHN0cmluZ1xyXG4gIH0pIHtcclxuICAgIGNvbnNvbGUubG9nKCfwn4+iIENyZWF0aW5nIG5ldyBjbGllbnQ6JywgY2xpZW50RGF0YSlcclxuICAgIHJldHVybiB0aGlzLnBvc3Q8e1xyXG4gICAgICBzdWNjZXNzOiBib29sZWFuXHJcbiAgICAgIGNsaWVudDogYW55XHJcbiAgICAgIGNyZWRlbnRpYWxzOiB7XHJcbiAgICAgICAgYXBpS2V5OiBzdHJpbmdcclxuICAgICAgICBqd3RUb2tlbjogc3RyaW5nXHJcbiAgICAgIH1cclxuICAgICAgbWVzc2FnZTogc3RyaW5nXHJcbiAgICB9PignL2FwaS9jbGllbnRzJywgY2xpZW50RGF0YSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjbGllbnQgcHJvZmlsZVxyXG4gICAqL1xyXG4gIGFzeW5jIGdldENsaWVudFByb2ZpbGUoY2xpZW50SWQ6IHN0cmluZykge1xyXG4gICAgY29uc29sZS5sb2coYPCfkaQgRmV0Y2hpbmcgY2xpZW50IHByb2ZpbGUgZm9yICR7Y2xpZW50SWR9YClcclxuICAgIHJldHVybiB0aGlzLmdldDx7XHJcbiAgICAgIHN1Y2Nlc3M6IGJvb2xlYW5cclxuICAgICAgY2xpZW50OiBhbnlcclxuICAgIH0+KGAvYXBpL2NsaWVudHMvJHtjbGllbnRJZH1gKVxyXG4gIH1cclxufVxyXG5cclxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZXNcclxuZXhwb3J0IGNvbnN0IGNhbGVuZGFyQXBpID0gbmV3IENhbGVuZGFyQXBpQ2xpZW50KClcclxuZXhwb3J0IGNvbnN0IGNsaWVudEFwaSA9IG5ldyBDbGllbnRBcGlDbGllbnQoKVxyXG5cclxuLy8gRXhwb3J0IGNsYXNzZXMgZm9yIGN1c3RvbSBpbnN0YW5jZXNcclxuZXhwb3J0IHsgQXBpQ2xpZW50LCBBcGlFcnJvciB9ICJdLCJuYW1lcyI6WyJBcGlDbGllbnQiLCJjcmVhdGVSZXF1ZXN0SWQiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiY2FuY2VsUmVxdWVzdCIsInJlcXVlc3RJZCIsImNvbnRyb2xsZXIiLCJhYm9ydENvbnRyb2xsZXJzIiwiZ2V0IiwiYWJvcnQiLCJkZWxldGUiLCJmb3JFYWNoIiwiY2xlYXIiLCJyZXF1ZXN0IiwiZW5kcG9pbnQiLCJvcHRpb25zIiwicmV0cmllcyIsImNvbmZpZyIsIkFib3J0Q29udHJvbGxlciIsInNldCIsInVybCIsImJhc2VVcmwiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsInJlc3BvbnNlIiwiZmV0Y2giLCJzaWduYWwiLCJoZWFkZXJzIiwiand0VG9rZW4iLCJjbGVhclRpbWVvdXQiLCJvayIsImVycm9yIiwiRXJyb3IiLCJzdGF0dXNUZXh0Iiwic3RhdHVzIiwiZXJyb3JEYXRhIiwianNvbiIsIm1lc3NhZ2UiLCJkZXRhaWxzIiwiZGVsYXkiLCJkYXRhIiwibmFtZSIsInRpbWVvdXRFcnJvciIsImNvZGUiLCJpc05ldHdvcmtFcnJvciIsIm1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJtZXRob2QiLCJwb3N0IiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1bmRlZmluZWQiLCJwdXQiLCJzZXRUb2tlbiIsInRva2VuIiwiY29uc3RydWN0b3IiLCJNYXAiLCJDYWxlbmRhckFwaUNsaWVudCIsImdldEF2YWlsYWJpbGl0eSIsInBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImRhdGUiLCJhcHBlbmQiLCJkdXJhdGlvbiIsImNvdW50IiwiY29uc29sZSIsImxvZyIsImJvb2tBcHBvaW50bWVudCIsImNoZWNrSGVhbHRoIiwiZ2V0Q2xpZW50TWV0cmljcyIsImNsaWVudElkIiwicGVyaW9kIiwiZ2V0Q2xpZW50Qm9va2luZ3MiLCJsaW1pdCIsInRlc3RDb25uZWN0aW9uIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJORVhUX1BVQkxJQ19KV1RfVE9LRU4iLCJDQUxFTkRBUl9BUElfSldUX1RPS0VOIiwiZW52aXJvbm1lbnQiLCJoYXNUb2tlbiIsInRva2VuUHJldmlldyIsInN1YnN0cmluZyIsIkNsaWVudEFwaUNsaWVudCIsImNyZWF0ZUNsaWVudCIsImNsaWVudERhdGEiLCJnZXRDbGllbnRQcm9maWxlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImNhbGVuZGFyQXBpIiwiY2xpZW50QXBpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api-client.ts\n"));

/***/ })

});